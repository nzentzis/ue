module Data.Units (
    module Data.Units.Types,
    module Data.Units.MKS,
    displayUnit
    ) where

import Data.Units.Types
import Data.Units.MKS
import Data.Display

import Data.List
import Data.Maybe
import Data.Function

import Control.Monad
import Control.Applicative
import Control.Arrow

import Debug.Trace

systems :: [UnitSystem]
systems = [mks]

findBaseUnit :: (Rational, BaseUnit) -> Maybe BaseUnit
findBaseUnit (n,u) = if n /= 1 then Nothing else Just u

findAtomicUnit :: AnonymousUnit -> Maybe DerivedUnit
findAtomicUnit (AnonymousUnit tb) = listToMaybe results where
    results = catMaybes $ map findInSystem systems
    findInSystem = find (\(DerivedUnit _ _ ts bs)->(ts,bs)==tb) . atomicUnits

findDerivedUnit :: AnonymousUnit -> Maybe DerivedUnit
findDerivedUnit (AnonymousUnit tb) = listToMaybe results where
        results = catMaybes $ map findInSystem systems
        findInSystem s = find (\(DerivedUnit _ _ ts bs)->(ts,bs)==tb) $
            derivedUnits s

data NamedUnit = Base BaseUnit | Derived DerivedUnit deriving (Eq,Show)

-- decomposed units use negative exponents for fractions
type DecomposedUnit = [(Rational, NamedUnit, Int)]

-- all versions of a decomposed unit generated by factoring out a unit, paired
-- with the unit that was removed in each case
removals :: DecomposedUnit -> [((Rational, NamedUnit, Int), DecomposedUnit)]
removals [] = []
removals l@(x@(n,u,e):xs)
    | e == 0  = ((n,u,0),xs):rest
    | e == -1 = ((n,u,-1),xs):rest
    | e < -1  = ((n,u,-1),(n,u,e+1):xs):rest
    | e == 1  = ((n,u,1),xs):rest
    | e > 1   = ((n,u,1),(n,u,e-1):xs):rest
    where rest = map (\(y,ys)->(y,x:ys)) (removals xs)

traces x = trace (show x) x

-- |Find the best decomposition of a unit into base/derived units
-- This works by exhaustive search over a tree where each node is an expression
-- and each edge removes one of the unit's components or reduces one of their
-- exponents. For example, the unit (kg*s) would generate a tree that looks like
--       kg*s
--      /    \
--     | s    | kg
--    kg      s
-- 
-- If exploring a node which is the definition of a derived unit, then that will
-- be generated rather than exploring the tree further. The final result is the
-- simplest decomposition in the tree.
--
-- After finishing, we have to go through and re-group units, since the tree
-- decomposition may have split exponents apart
decomposeUnit :: DecomposedUnit -> DecomposedUnit
decomposeUnit [] = []
decomposeUnit us = fromMaybe (minimumBy (compare `on` metric) children) derived
    where
    metric :: DecomposedUnit -> Int
    metric us = length us -- currently using expression size as a metric

    -- multiply a unit by a decomposed unit, combining exponents
    smartMul :: (Rational,NamedUnit,Int) -> DecomposedUnit -> DecomposedUnit
    smartMul e@(f,u,p) us =
        (\(x,y)->x ++ case y of
            [] -> [e]
            ((_,_,p'):ys) -> (f,u,p+p'):ys) $
        break (\(a,b,_)->(a,b) == (f,u)) us

    -- generate children of this node, and recursively search each one
    children :: [DecomposedUnit]
    children = map (\(x,r)->smartMul x $ decomposeUnit r) $ removals us

    -- a derived unit for this node, if available
    derived :: Maybe DecomposedUnit
    derived = fmap (\u->[(1, Derived u, 1)]) (recompose us >>= findDerivedUnit)

-- |Build a decomposed unit sequence from a derived unit
-- this is a multi-step process, starting with the units in the numerator and
-- denominator of the derived unit's fractional representation:
--     1. sort the top and bottom units, so equal units are grouped
--     2. convert multiple copies of a unit to one copy with an exponent
--     3. invert exponents of units in the denominator
--     4. concatenate the two
--     5. convert all base units to NamedUnits
-- once done, the result is the same unit in decomposed form
decompose :: Unit a => a -> DecomposedUnit
decompose u =
        map (\(a,b,c)->(a, Base b, c)) $ -- add Base tags
        (\(a,b)->a ++ b) $ -- join the final result
        second (map inv) $ -- invert exponents of denominator
        both (map (\((a,b):us)->(a,b,1+length us))) $ -- add exponents
        both group $       -- group similar units
        both sort $        -- sort before grouping
        (\(AnonymousUnit t)->t) $ toFrac u where
    -- apply a function to both elements of a tuple
    both :: (a -> b) -> (a,a) -> (b,b)
    both f = first f . second f
    inv (a,b,c) = (a,b,-c) -- invert the factor's exponent

-- |Compose an AnonymousUnit from a decomposed form, if possible
-- If the decomposed form includes derived units, this function will fail.
recompose :: DecomposedUnit -> Maybe AnonymousUnit
recompose us = AnonymousUnit <$> (liftM2 (,) top btm) where
    -- reverse the decomposition's grouping, converting exponents to sequences
    ungroup :: [(a,b,Int)] -> [(a,b)]
    ungroup = concatMap (\(a,b,n)->replicate n (a,b))
    -- extract a base unit from a NamedUnit
    unname :: (Rational,NamedUnit) -> Maybe (Rational,BaseUnit)
    unname (r,Base b) = Just (r,b)
    unname (_,_) = Nothing
    -- convert numerator and denominator
    top :: Maybe [(Rational,BaseUnit)]
    top = mapM unname $ ungroup $ filter (\(_,_,n)->n > 0) us
    btm :: Maybe [(Rational,BaseUnit)]
    btm = mapM unname $ ungroup $ -- have to flip signs for ungroup to work
        map (\(a,b,n)->(a,b,-n)) $ filter (\(_,_,n)->n < 0) us

-- |Render the pieces of a decomposed unit
renderUnit :: DecomposedUnit -> String
renderUnit us = intercalate "*" $ map showPiece us where
    -- TODO: handle rational multiples of units
    showPiece :: (Rational, NamedUnit, Int) -> String
    showPiece (_,u,p)
        | p < 0  = showUnit u ++ "^(" ++ show p ++ ")"
        | p == 1 = showUnit u
        | p > 1  = showUnit u ++ "^" ++ show p
        | otherwise = show (u,p)

    showUnit :: NamedUnit -> String
    showUnit (Base (BaseUnit a _ _)) = a
    showUnit (Derived (DerivedUnit a _ _ _)) = a

displayUnit :: Unit a => a -> String
displayUnit u = case findAtomicUnit $ toFrac u of
    Nothing -> renderUnit $ decomposeUnit $ decompose u
    Just (DerivedUnit a n _ _) -> a

instance Displayable AnonymousUnit where
    display = (\x->[(Units,x)]) . displayUnit
