module Data.Units (
    module Data.Units.Types,
    module Data.Units.MKS,
    displayUnit
    ) where

import Data.Units.Types
import Data.Units.MKS

import Data.List
import Data.Maybe
import Data.Function
import Control.Applicative

systems :: [UnitSystem]
systems = [mks]

findBaseUnit :: (Rational, BaseUnit) -> Maybe BaseUnit
findBaseUnit (n,u) = if n /= 1 then Nothing else Just u

findDerivedUnit :: AnonymousUnit -> Maybe DerivedUnit
findDerivedUnit (AnonymousUnit tb) = (case results of
    [] -> Nothing
    (x:_) -> Just x) where
        results = catMaybes $ map findInSystem systems
        findInSystem s = find (\(DerivedUnit _ _ ts bs)->(ts,bs)==tb) $
            derivedUnits s

data NamedUnit = Base BaseUnit | Derived DerivedUnit

-- decomposed units use negative exponents for fractions
type DecomposedUnit = [(Rational, NamedUnit, Int)]

-- all versions of a sequence generated by removing an element, paired with the
-- element that was removed in each case
removals :: [a] -> [(a, [a])]
removals [] = []
removals [x] = [(x, [])]
removals l@(x:xs) = (x,xs):(map (\(y,ys)->(y,x:ys)) (removals xs))

-- find the highest-level decomposition of a unit into base/derived units via
-- breadth-first removal. Units normally aren't large, so this shouldn't cause
-- a serious performance hit.
decomposeUnit :: DecomposedUnit -> DecomposedUnit
decomposeUnit us = minimumBy (compare `on` metric) opts where
    metric :: DecomposedUnit -> Int
    metric us = length us
    opts :: [DecomposedUnit]
    opts = map (\(x,r)->x:decomposeUnit r) $ removals us

-- Build a decomposed unit sequence from a derived unit
decompose :: DerivedUnit -> DecomposedUnit
decompose (DerivedUnit _ _ ts bs) = shrink (ts,bs) where
    both :: (a -> b) -> (a,a) -> (b,b)
    both f (x,y) = (f x,f y)
    inv (a,b,c) = (a,b,-c) -- invert the factor's exponent
    exponent = both (map (\((a,b):us)->(a,b,1+length us))) . both group
    joinFrac (a,b) = a ++ inv b
    shrink = joinFrac . (both $ map (\(a,b,c)->(a,Base b,c))) . exponent

renderUnit :: Unit a => a -> String
renderUnit x = if null btm then top else concat [top,"/",btm] where
    (AnonymousUnit t) = reduceUnit $ toFrac x
    grouped = both group t
    exponented = both (map (\(us)->(head us,length us))) grouped
    (top,btm) = both (concat . map (uncurry showExp)) exponented
    showExp p n = if n == 1 then showPt p else concat [showPt p,"^",show n]
    showPt p = fromJust ((fmap (\(BaseUnit a _ _)->a) $ findBaseUnit p) <|>
        (fmap (\(DerivedUnit a _ _ _)->a) $ findDerivedUnit $
            AnonymousUnit ([p],[])) <|>
        Just "<?>")

displayUnit :: Unit a => a -> String
displayUnit u = let u' = toFrac u in maybe (renderUnit u)
    (\(DerivedUnit a _ _ _)->a) (findDerivedUnit u')
